
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>password-generator: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/romdj/password-generator/config.go (97.8%)</option>
				
				<option value="file1">github.com/romdj/password-generator/main.go (23.5%)</option>
				
				<option value="file2">github.com/romdj/password-generator/policy.go (100.0%)</option>
				
				<option value="file3">github.com/romdj/password-generator/strength.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "gopkg.in/yaml.v3"
)

type Config struct {
        Length           int    `yaml:"length"`
        IncludeUpper     bool   `yaml:"include_upper"`
        IncludeLower     bool   `yaml:"include_lower"`
        IncludeDigits    bool   `yaml:"include_digits"`
        IncludeSymbols   bool   `yaml:"include_symbols"`
        ExcludeAmbiguous bool   `yaml:"exclude_ambiguous"`
        Count            int    `yaml:"count"`
        ShowStrength     bool   `yaml:"show_strength"`
        PolicyTemplate   string `yaml:"policy_template"`
}

func DefaultConfig() Config <span class="cov7" title="7">{
        return Config{
                Length:           12,
                IncludeUpper:     true,
                IncludeLower:     true,
                IncludeDigits:    true,
                IncludeSymbols:   false,
                ExcludeAmbiguous: false,
                Count:            1,
                ShowStrength:     false,
                PolicyTemplate:   "",
        }
}</span>

func LoadConfig() (Config, error) <span class="cov3" title="2">{
        config := DefaultConfig()

        // Load from config files (in order of precedence)
        configPaths := []string{
                ".pwgen.yaml",
                ".pwgen.yml",
        }

        // Add home directory config paths
        if homeDir, err := os.UserHomeDir(); err == nil </span><span class="cov3" title="2">{
                configPaths = append(configPaths,
                        filepath.Join(homeDir, ".pwgen.yaml"),
                        filepath.Join(homeDir, ".pwgen.yml"),
                        filepath.Join(homeDir, ".config", "pwgen", "config.yaml"),
                        filepath.Join(homeDir, ".config", "pwgen", "config.yml"),
                )
        }</span>

        <span class="cov3" title="2">for _, path := range configPaths </span><span class="cov7" title="7">{
                if err := loadConfigFromFile(path, &amp;config); err == nil </span><span class="cov1" title="1">{
                        break</span> // Use first config file found
                }
        }

        // Override with environment variables
        <span class="cov3" title="2">loadConfigFromEnv(&amp;config)

        return config, nil</span>
}

func loadConfigFromFile(path string, config *Config) error <span class="cov7" title="9">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov7" title="7">{
                return err
        }</span>

        <span class="cov3" title="2">return yaml.Unmarshal(data, config)</span>
}

func loadConfigFromEnv(config *Config) <span class="cov5" title="4">{
        if val := os.Getenv("PWGEN_LENGTH"); val != "" </span><span class="cov3" title="2">{
                if length, err := strconv.Atoi(val); err == nil </span><span class="cov3" title="2">{
                        config.Length = length
                }</span>
        }

        <span class="cov5" title="4">if val := os.Getenv("PWGEN_INCLUDE_UPPER"); val != "" </span><span class="cov1" title="1">{
                config.IncludeUpper = parseBool(val, config.IncludeUpper)
        }</span>

        <span class="cov5" title="4">if val := os.Getenv("PWGEN_INCLUDE_LOWER"); val != "" </span><span class="cov1" title="1">{
                config.IncludeLower = parseBool(val, config.IncludeLower)
        }</span>

        <span class="cov5" title="4">if val := os.Getenv("PWGEN_INCLUDE_DIGITS"); val != "" </span><span class="cov1" title="1">{
                config.IncludeDigits = parseBool(val, config.IncludeDigits)
        }</span>

        <span class="cov5" title="4">if val := os.Getenv("PWGEN_INCLUDE_SYMBOLS"); val != "" </span><span class="cov3" title="2">{
                config.IncludeSymbols = parseBool(val, config.IncludeSymbols)
        }</span>

        <span class="cov5" title="4">if val := os.Getenv("PWGEN_EXCLUDE_AMBIGUOUS"); val != "" </span><span class="cov1" title="1">{
                config.ExcludeAmbiguous = parseBool(val, config.ExcludeAmbiguous)
        }</span>

        <span class="cov5" title="4">if val := os.Getenv("PWGEN_COUNT"); val != "" </span><span class="cov1" title="1">{
                if count, err := strconv.Atoi(val); err == nil </span><span class="cov1" title="1">{
                        config.Count = count
                }</span>
        }

        <span class="cov5" title="4">if val := os.Getenv("PWGEN_SHOW_STRENGTH"); val != "" </span><span class="cov3" title="2">{
                config.ShowStrength = parseBool(val, config.ShowStrength)
        }</span>

        <span class="cov5" title="4">if val := os.Getenv("PWGEN_POLICY_TEMPLATE"); val != "" </span><span class="cov1" title="1">{
                config.PolicyTemplate = val
        }</span>
}

func parseBool(val string, defaultValue bool) bool <span class="cov10" title="18">{
        switch strings.ToLower(val) </span>{
        case "true", "1", "yes", "on", "enable", "enabled":<span class="cov8" title="10">
                return true</span>
        case "false", "0", "no", "off", "disable", "disabled":<span class="cov6" title="6">
                return false</span>
        default:<span class="cov3" title="2">
                return defaultValue</span>
        }
}

func (c Config) ToPasswordConfig() PasswordConfig <span class="cov1" title="1">{
        return PasswordConfig{
                Length:           c.Length,
                IncludeUpper:     c.IncludeUpper,
                IncludeLower:     c.IncludeLower,
                IncludeDigits:    c.IncludeDigits,
                IncludeSymbols:   c.IncludeSymbols,
                ExcludeAmbiguous: c.ExcludeAmbiguous,
        }
}</span>

func SaveConfigExample(path string) error <span class="cov4" title="3">{
        config := Config{
                Length:           16,
                IncludeUpper:     true,
                IncludeLower:     true,
                IncludeDigits:    true,
                IncludeSymbols:   true,
                ExcludeAmbiguous: true,
                Count:            1,
                ShowStrength:     true,
                PolicyTemplate:   "corporate",
        }

        data, err := yaml.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        // Add header comment
        <span class="cov4" title="3">header := `# Password Generator Configuration
# This file contains default settings for the password generator
# Place this file in your home directory as ~/.pwgen.yaml or in the current directory as .pwgen.yaml
# Environment variables (PWGEN_*) will override these settings
# Command-line flags will override both config file and environment variables

`

        content := header + string(data)

        return os.WriteFile(path, []byte(content), 0644)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "crypto/rand"
        "flag"
        "fmt"
        "log"
        "math/big"
        "os"
        "strings"
)

type PasswordConfig struct {
        Length           int
        IncludeUpper     bool
        IncludeLower     bool
        IncludeDigits    bool
        IncludeSymbols   bool
        ExcludeAmbiguous bool
}

const (
        LowerCase = "abcdefghijklmnopqrstuvwxyz"
        UpperCase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        Digits    = "0123456789"
        Symbols   = "!@#$%^&amp;*()_+-=[]{}|;:,.&lt;&gt;?"
        Ambiguous = "0O1lI"
)

func main() <span class="cov0" title="0">{
        // Load configuration from files and environment
        baseConfig, err := LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Warning: Could not load config: %v\n", err)
                baseConfig = DefaultConfig()
        }</span>

        // Convert to PasswordConfig for compatibility
        <span class="cov0" title="0">config := baseConfig.ToPasswordConfig()
        count := baseConfig.Count
        showStrength := baseConfig.ShowStrength
        policyTemplate := baseConfig.PolicyTemplate

        // Command line flags override config
        flag.IntVar(&amp;config.Length, "length", config.Length, "Password length")
        flag.IntVar(&amp;config.Length, "l", config.Length, "Password length (short)")
        flag.BoolVar(&amp;config.IncludeUpper, "upper", config.IncludeUpper, "Include uppercase letters")
        flag.BoolVar(&amp;config.IncludeUpper, "u", config.IncludeUpper, "Include uppercase letters (short)")
        flag.BoolVar(&amp;config.IncludeLower, "lower", config.IncludeLower, "Include lowercase letters")
        flag.BoolVar(&amp;config.IncludeLower, "L", config.IncludeLower, "Include lowercase letters (short)")
        flag.BoolVar(&amp;config.IncludeDigits, "digits", config.IncludeDigits, "Include digits")
        flag.BoolVar(&amp;config.IncludeDigits, "d", config.IncludeDigits, "Include digits (short)")
        flag.BoolVar(&amp;config.IncludeSymbols, "symbols", config.IncludeSymbols, "Include symbols")
        flag.BoolVar(&amp;config.IncludeSymbols, "s", config.IncludeSymbols, "Include symbols (short)")
        flag.BoolVar(&amp;config.ExcludeAmbiguous, "no-ambiguous", config.ExcludeAmbiguous, "Exclude ambiguous characters (0, O, 1, l, I)")
        flag.BoolVar(&amp;config.ExcludeAmbiguous, "n", config.ExcludeAmbiguous, "Exclude ambiguous characters (short)")

        flag.IntVar(&amp;count, "count", count, "Number of passwords to generate")
        countShort := flag.Int("c", count, "Number of passwords to generate (short)")
        flag.BoolVar(&amp;showStrength, "strength", showStrength, "Show password strength analysis")
        flag.BoolVar(&amp;showStrength, "S", showStrength, "Show password strength analysis (short)")
        flag.StringVar(&amp;policyTemplate, "policy", policyTemplate, "Apply password policy template")
        flag.StringVar(&amp;policyTemplate, "p", policyTemplate, "Apply password policy template (short)")

        listPolicies := flag.Bool("list-policies", false, "List available password policy templates")
        validateOnly := flag.String("validate", "", "Validate a password against policy without generating")
        saveConfig := flag.String("save-config", "", "Save example configuration to file")

        flag.Parse()

        // Handle special commands
        if *listPolicies </span><span class="cov0" title="0">{
                fmt.Println("Available password policy templates:")
                for _, name := range ListPolicies() </span><span class="cov0" title="0">{
                        policy, _ := GetPolicy(name)
                        fmt.Printf("  %-15s - %s\n", name, policy.Description)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if *saveConfig != "" </span><span class="cov0" title="0">{
                if err := SaveConfigExample(*saveConfig); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error saving config: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Example configuration saved to %s\n", *saveConfig)
                return</span>
        }

        <span class="cov0" title="0">if *validateOnly != "" </span><span class="cov0" title="0">{
                if policyTemplate == "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error: --policy required when using --validate\n")
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">policy, err := GetPolicy(policyTemplate)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">violations := ValidatePasswordAgainstPolicy(*validateOnly, policy)
                if len(violations) == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("✓ Password meets %s policy requirements\n", policy.Name)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("✗ Password violates %s policy:\n", policy.Name)
                        for _, violation := range violations </span><span class="cov0" title="0">{
                                fmt.Printf("  - %s\n", violation.Description)
                        }</span>
                }
                <span class="cov0" title="0">return</span>
        }

        // Apply policy template if specified
        <span class="cov0" title="0">var policy PasswordPolicy
        if policyTemplate != "" </span><span class="cov0" title="0">{
                p, err := GetPolicy(policyTemplate)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                        fmt.Fprintf(os.Stderr, "Available policies: %s\n", strings.Join(ListPolicies(), ", "))
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">policy = p
                ApplyPolicyToConfig(policy, &amp;config)</span>
        }

        // Use short flag if set
        <span class="cov0" title="0">if *countShort != count </span><span class="cov0" title="0">{
                count = *countShort
        }</span>

        <span class="cov0" title="0">if err := validateConfig(config); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                password, err := generatePassword(config)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to generate password: %v", err)
                }</span>

                <span class="cov0" title="0">fmt.Print(password)

                // Show strength analysis if requested
                if showStrength </span><span class="cov0" title="0">{
                        strength := AnalyzePasswordStrength(password)
                        fmt.Printf(" [%s%s\033[0m, Score: %d/100, Entropy: %.1f bits, Time to crack: %s]",
                                strength.Level.Color(),
                                strength.Level.String(),
                                strength.Score,
                                strength.Entropy,
                                strength.TimeToCrack,
                        )

                        if len(strength.Feedback) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("\n  Feedback: %s", strings.Join(strength.Feedback, "; "))
                        }</span>
                }

                // Validate against policy if specified
                <span class="cov0" title="0">if policyTemplate != "" </span><span class="cov0" title="0">{
                        violations := ValidatePasswordAgainstPolicy(password, policy)
                        if len(violations) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf(" [Policy violations: %d]", len(violations))
                                if showStrength </span><span class="cov0" title="0">{
                                        fmt.Printf("\n  Violations:")
                                        for _, violation := range violations </span><span class="cov0" title="0">{
                                                fmt.Printf("\n    - %s", violation.Description)
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">fmt.Println()</span>
        }
}

func validateConfig(config PasswordConfig) error <span class="cov3" title="3">{
        if config.Length &lt; 1 </span><span class="cov1" title="1">{
                return fmt.Errorf("password length must be at least 1")
        }</span>

        <span class="cov2" title="2">if !config.IncludeUpper &amp;&amp; !config.IncludeLower &amp;&amp; !config.IncludeDigits &amp;&amp; !config.IncludeSymbols </span><span class="cov1" title="1">{
                return fmt.Errorf("at least one character type must be enabled")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func generatePassword(config PasswordConfig) (string, error) <span class="cov4" title="7">{
        charset := buildCharset(config)

        if len(charset) == 0 </span><span class="cov1" title="1">{
                return "", fmt.Errorf("no valid characters available for password generation")
        }</span>

        <span class="cov4" title="6">password := make([]byte, config.Length)

        for i := 0; i &lt; config.Length; i++ </span><span class="cov10" title="137">{
                randomIndex, err := rand.Int(rand.Reader, big.NewInt(int64(len(charset))))
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to generate random number: %w", err)
                }</span>
                <span class="cov10" title="137">password[i] = charset[randomIndex.Int64()]</span>
        }

        <span class="cov4" title="6">return string(password), nil</span>
}

func buildCharset(config PasswordConfig) string <span class="cov5" title="10">{
        var charset strings.Builder

        if config.IncludeLower </span><span class="cov4" title="6">{
                charset.WriteString(LowerCase)
        }</span>

        <span class="cov5" title="10">if config.IncludeUpper </span><span class="cov4" title="6">{
                charset.WriteString(UpperCase)
        }</span>

        <span class="cov5" title="10">if config.IncludeDigits </span><span class="cov3" title="5">{
                charset.WriteString(Digits)
        }</span>

        <span class="cov5" title="10">if config.IncludeSymbols </span><span class="cov3" title="3">{
                charset.WriteString(Symbols)
        }</span>

        <span class="cov5" title="10">result := charset.String()

        if config.ExcludeAmbiguous </span><span class="cov2" title="2">{
                for _, char := range Ambiguous </span><span class="cov5" title="10">{
                        result = strings.ReplaceAll(result, string(char), "")
                }</span>
        }

        <span class="cov5" title="10">return result</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"
        "regexp"
        "strings"
)

type PasswordPolicy struct {
        Name              string   `yaml:"name"`
        Description       string   `yaml:"description"`
        MinLength         int      `yaml:"min_length"`
        MaxLength         int      `yaml:"max_length"`
        RequireUpper      bool     `yaml:"require_upper"`
        RequireLower      bool     `yaml:"require_lower"`
        RequireDigits     bool     `yaml:"require_digits"`
        RequireSymbols    bool     `yaml:"require_symbols"`
        MinUpper          int      `yaml:"min_upper"`
        MinLower          int      `yaml:"min_lower"`
        MinDigits         int      `yaml:"min_digits"`
        MinSymbols        int      `yaml:"min_symbols"`
        ExcludeAmbiguous  bool     `yaml:"exclude_ambiguous"`
        ForbiddenChars    string   `yaml:"forbidden_chars"`
        ForbiddenPatterns []string `yaml:"forbidden_patterns"`
        MinEntropy        float64  `yaml:"min_entropy"`
}

type PolicyViolation struct {
        Rule        string
        Description string
}

var BuiltinPolicies = map[string]PasswordPolicy{
        "basic": {
                Name:              "Basic Security",
                Description:       "Minimal security requirements suitable for low-risk applications",
                MinLength:         8,
                MaxLength:         0, // No limit
                RequireUpper:      true,
                RequireLower:      true,
                RequireDigits:     true,
                RequireSymbols:    false,
                MinUpper:          1,
                MinLower:          1,
                MinDigits:         1,
                MinSymbols:        0,
                ExcludeAmbiguous:  false,
                ForbiddenChars:    "",
                ForbiddenPatterns: []string{"password", "123456", "qwerty"},
                MinEntropy:        25,
        },
        "corporate": {
                Name:              "Corporate Standard",
                Description:       "Standard corporate password policy with moderate security",
                MinLength:         12,
                MaxLength:         0,
                RequireUpper:      true,
                RequireLower:      true,
                RequireDigits:     true,
                RequireSymbols:    true,
                MinUpper:          2,
                MinLower:          2,
                MinDigits:         2,
                MinSymbols:        1,
                ExcludeAmbiguous:  true,
                ForbiddenChars:    "",
                ForbiddenPatterns: []string{"password", "123456", "qwerty", "admin", "login", "welcome"},
                MinEntropy:        40,
        },
        "high-security": {
                Name:             "High Security",
                Description:      "Stringent requirements for high-security environments",
                MinLength:        16,
                MaxLength:        0,
                RequireUpper:     true,
                RequireLower:     true,
                RequireDigits:    true,
                RequireSymbols:   true,
                MinUpper:         3,
                MinLower:         3,
                MinDigits:        3,
                MinSymbols:       2,
                ExcludeAmbiguous: true,
                ForbiddenChars:   "",
                ForbiddenPatterns: []string{
                        "password", "123456", "qwerty", "admin", "login", "welcome",
                        "letmein", "monkey", "dragon", "master", "shadow", "football",
                },
                MinEntropy: 60,
        },
        "aws": {
                Name:              "AWS IAM Policy",
                Description:       "Meets AWS IAM password policy requirements",
                MinLength:         8,
                MaxLength:         128,
                RequireUpper:      true,
                RequireLower:      true,
                RequireDigits:     true,
                RequireSymbols:    true,
                MinUpper:          1,
                MinLower:          1,
                MinDigits:         1,
                MinSymbols:        1,
                ExcludeAmbiguous:  false,
                ForbiddenChars:    "",
                ForbiddenPatterns: []string{},
                MinEntropy:        30,
        },
        "azure": {
                Name:              "Azure AD Policy",
                Description:       "Meets Azure AD password complexity requirements",
                MinLength:         8,
                MaxLength:         256,
                RequireUpper:      true,
                RequireLower:      true,
                RequireDigits:     true,
                RequireSymbols:    true,
                MinUpper:          1,
                MinLower:          1,
                MinDigits:         1,
                MinSymbols:        1,
                ExcludeAmbiguous:  false,
                ForbiddenChars:    "",
                ForbiddenPatterns: []string{},
                MinEntropy:        35,
        },
        "pci-dss": {
                Name:              "PCI DSS Compliant",
                Description:       "Meets PCI DSS password requirements for payment systems",
                MinLength:         7,
                MaxLength:         0,
                RequireUpper:      true,
                RequireLower:      true,
                RequireDigits:     true,
                RequireSymbols:    false,
                MinUpper:          1,
                MinLower:          1,
                MinDigits:         1,
                MinSymbols:        0,
                ExcludeAmbiguous:  false,
                ForbiddenChars:    "",
                ForbiddenPatterns: []string{},
                MinEntropy:        28,
        },
}

func GetPolicy(name string) (PasswordPolicy, error) <span class="cov5" title="7">{
        if policy, exists := BuiltinPolicies[name]; exists </span><span class="cov5" title="6">{
                return policy, nil
        }</span>
        <span class="cov1" title="1">return PasswordPolicy{}, fmt.Errorf("policy '%s' not found", name)</span>
}

func ListPolicies() []string <span class="cov1" title="1">{
        var policies []string
        for name := range BuiltinPolicies </span><span class="cov5" title="6">{
                policies = append(policies, name)
        }</span>
        <span class="cov1" title="1">return policies</span>
}

func ValidatePasswordAgainstPolicy(password string, policy PasswordPolicy) []PolicyViolation <span class="cov6" title="10">{
        var violations []PolicyViolation

        // Length checks
        if len(password) &lt; policy.MinLength </span><span class="cov3" title="3">{
                violations = append(violations, PolicyViolation{
                        Rule:        "MinLength",
                        Description: fmt.Sprintf("Password must be at least %d characters long", policy.MinLength),
                })
        }</span>

        <span class="cov6" title="10">if policy.MaxLength &gt; 0 &amp;&amp; len(password) &gt; policy.MaxLength </span><span class="cov1" title="1">{
                violations = append(violations, PolicyViolation{
                        Rule:        "MaxLength",
                        Description: fmt.Sprintf("Password must not exceed %d characters", policy.MaxLength),
                })
        }</span>

        // Character type requirements
        <span class="cov6" title="10">upperCount := countMatches(password, `[A-Z]`)
        lowerCount := countMatches(password, `[a-z]`)
        digitCount := countMatches(password, `[0-9]`)
        symbolCount := countMatches(password, `[^a-zA-Z0-9]`)

        if policy.RequireUpper &amp;&amp; upperCount == 0 </span><span class="cov2" title="2">{
                violations = append(violations, PolicyViolation{
                        Rule:        "RequireUpper",
                        Description: "Password must contain at least one uppercase letter",
                })
        }</span>

        <span class="cov6" title="10">if policy.RequireLower &amp;&amp; lowerCount == 0 </span><span class="cov1" title="1">{
                violations = append(violations, PolicyViolation{
                        Rule:        "RequireLower",
                        Description: "Password must contain at least one lowercase letter",
                })
        }</span>

        <span class="cov6" title="10">if policy.RequireDigits &amp;&amp; digitCount == 0 </span><span class="cov2" title="2">{
                violations = append(violations, PolicyViolation{
                        Rule:        "RequireDigits",
                        Description: "Password must contain at least one digit",
                })
        }</span>

        <span class="cov6" title="10">if policy.RequireSymbols &amp;&amp; symbolCount == 0 </span><span class="cov2" title="2">{
                violations = append(violations, PolicyViolation{
                        Rule:        "RequireSymbols",
                        Description: "Password must contain at least one symbol",
                })
        }</span>

        // Minimum character counts
        <span class="cov6" title="10">if upperCount &lt; policy.MinUpper </span><span class="cov3" title="3">{
                violations = append(violations, PolicyViolation{
                        Rule:        "MinUpper",
                        Description: fmt.Sprintf("Password must contain at least %d uppercase letters", policy.MinUpper),
                })
        }</span>

        <span class="cov6" title="10">if lowerCount &lt; policy.MinLower </span><span class="cov1" title="1">{
                violations = append(violations, PolicyViolation{
                        Rule:        "MinLower",
                        Description: fmt.Sprintf("Password must contain at least %d lowercase letters", policy.MinLower),
                })
        }</span>

        <span class="cov6" title="10">if digitCount &lt; policy.MinDigits </span><span class="cov2" title="2">{
                violations = append(violations, PolicyViolation{
                        Rule:        "MinDigits",
                        Description: fmt.Sprintf("Password must contain at least %d digits", policy.MinDigits),
                })
        }</span>

        <span class="cov6" title="10">if symbolCount &lt; policy.MinSymbols </span><span class="cov2" title="2">{
                violations = append(violations, PolicyViolation{
                        Rule:        "MinSymbols",
                        Description: fmt.Sprintf("Password must contain at least %d symbols", policy.MinSymbols),
                })
        }</span>

        // Ambiguous character check
        <span class="cov6" title="10">if policy.ExcludeAmbiguous </span><span class="cov5" title="7">{
                ambiguous := "0O1lI"
                for _, char := range ambiguous </span><span class="cov8" title="24">{
                        if strings.ContainsRune(password, char) </span><span class="cov4" title="5">{
                                violations = append(violations, PolicyViolation{
                                        Rule:        "ExcludeAmbiguous",
                                        Description: fmt.Sprintf("Password must not contain ambiguous characters (%s)", ambiguous),
                                })
                                break</span>
                        }
                }
        }

        // Forbidden characters
        <span class="cov6" title="10">if policy.ForbiddenChars != "" </span><span class="cov4" title="5">{
                for _, char := range policy.ForbiddenChars </span><span class="cov7" title="15">{
                        if strings.ContainsRune(password, char) </span><span class="cov2" title="2">{
                                violations = append(violations, PolicyViolation{
                                        Rule:        "ForbiddenChars",
                                        Description: fmt.Sprintf("Password must not contain forbidden character '%c'", char),
                                })
                        }</span>
                }
        }

        // Forbidden patterns
        <span class="cov6" title="10">lower := strings.ToLower(password)
        for _, pattern := range policy.ForbiddenPatterns </span><span class="cov8" title="26">{
                if strings.Contains(lower, strings.ToLower(pattern)) </span><span class="cov1" title="1">{
                        violations = append(violations, PolicyViolation{
                                Rule:        "ForbiddenPatterns",
                                Description: fmt.Sprintf("Password must not contain forbidden pattern '%s'", pattern),
                        })
                }</span>
        }

        // Entropy check
        <span class="cov6" title="10">if policy.MinEntropy &gt; 0 </span><span class="cov6" title="10">{
                entropy := calculateEntropy(password)
                if entropy &lt; policy.MinEntropy </span><span class="cov4" title="5">{
                        violations = append(violations, PolicyViolation{
                                Rule:        "MinEntropy",
                                Description: fmt.Sprintf("Password entropy (%.1f bits) must be at least %.1f bits", entropy, policy.MinEntropy),
                        })
                }</span>
        }

        <span class="cov6" title="10">return violations</span>
}

func countMatches(text, pattern string) int <span class="cov10" title="40">{
        re := regexp.MustCompile(pattern)
        matches := re.FindAllString(text, -1)
        return len(matches)
}</span>

func ApplyPolicyToConfig(policy PasswordPolicy, config *PasswordConfig) <span class="cov5" title="6">{
        // Adjust length to meet minimum requirements
        if config.Length &lt; policy.MinLength </span><span class="cov2" title="2">{
                config.Length = policy.MinLength
        }</span>

        <span class="cov5" title="6">if policy.MaxLength &gt; 0 &amp;&amp; config.Length &gt; policy.MaxLength </span><span class="cov1" title="1">{
                config.Length = policy.MaxLength
        }</span>

        // Enable required character types
        <span class="cov5" title="6">if policy.RequireUpper </span><span class="cov2" title="2">{
                config.IncludeUpper = true
        }</span>

        <span class="cov5" title="6">if policy.RequireLower </span><span class="cov2" title="2">{
                config.IncludeLower = true
        }</span>

        <span class="cov5" title="6">if policy.RequireDigits </span><span class="cov2" title="2">{
                config.IncludeDigits = true
        }</span>

        <span class="cov5" title="6">if policy.RequireSymbols </span><span class="cov2" title="2">{
                config.IncludeSymbols = true
        }</span>

        // Apply ambiguous character exclusion
        <span class="cov5" title="6">if policy.ExcludeAmbiguous </span><span class="cov2" title="2">{
                config.ExcludeAmbiguous = true
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "math"
        "regexp"
        "strings"
)

type StrengthLevel int

const (
        VeryWeak StrengthLevel = iota
        Weak
        Fair
        Good
        Strong
        VeryStrong
)

func (s StrengthLevel) String() string <span class="cov3" title="14">{
        switch s </span>{
        case VeryWeak:<span class="cov1" title="2">
                return "Very Weak"</span>
        case Weak:<span class="cov1" title="2">
                return "Weak"</span>
        case Fair:<span class="cov1" title="2">
                return "Fair"</span>
        case Good:<span class="cov1" title="2">
                return "Good"</span>
        case Strong:<span class="cov1" title="2">
                return "Strong"</span>
        case VeryStrong:<span class="cov1" title="2">
                return "Very Strong"</span>
        default:<span class="cov1" title="2">
                return "Unknown"</span>
        }
}

func (s StrengthLevel) Color() string <span class="cov3" title="7">{
        switch s </span>{
        case VeryWeak:<span class="cov1" title="1">
                return "\033[91m"</span> // Red
        case Weak:<span class="cov1" title="1">
                return "\033[91m"</span> // Red
        case Fair:<span class="cov1" title="1">
                return "\033[93m"</span> // Yellow
        case Good:<span class="cov1" title="1">
                return "\033[93m"</span> // Yellow
        case Strong:<span class="cov1" title="1">
                return "\033[92m"</span> // Green
        case VeryStrong:<span class="cov1" title="1">
                return "\033[92m"</span> // Green
        default:<span class="cov1" title="1">
                return "\033[0m"</span> // Reset
        }
}

type PasswordStrength struct {
        Score       int
        Level       StrengthLevel
        Entropy     float64
        Feedback    []string
        TimeToCrack string
}

func AnalyzePasswordStrength(password string) PasswordStrength <span class="cov4" title="19">{
        score := 0
        var feedback []string

        length := len(password)

        // Length scoring
        if length &lt; 8 </span><span class="cov2" title="4">{
                feedback = append(feedback, "Use at least 8 characters")
        }</span> else<span class="cov3" title="15"> if length &lt; 12 </span><span class="cov1" title="2">{
                score += 10
                feedback = append(feedback, "Consider using 12+ characters for better security")
        }</span> else<span class="cov3" title="13"> if length &lt; 16 </span><span class="cov2" title="6">{
                score += 20
        }</span> else<span class="cov3" title="7"> {
                score += 30
        }</span>

        // Character variety scoring
        <span class="cov4" title="19">hasLower := regexp.MustCompile(`[a-z]`).MatchString(password)
        hasUpper := regexp.MustCompile(`[A-Z]`).MatchString(password)
        hasDigit := regexp.MustCompile(`[0-9]`).MatchString(password)
        hasSymbol := regexp.MustCompile(`[^a-zA-Z0-9]`).MatchString(password)

        varietyCount := 0
        if hasLower </span><span class="cov4" title="17">{
                varietyCount++
                score += 10
        }</span> else<span class="cov1" title="2"> {
                feedback = append(feedback, "Add lowercase letters")
        }</span>

        <span class="cov4" title="19">if hasUpper </span><span class="cov3" title="12">{
                varietyCount++
                score += 10
        }</span> else<span class="cov3" title="7"> {
                feedback = append(feedback, "Add uppercase letters")
        }</span>

        <span class="cov4" title="19">if hasDigit </span><span class="cov3" title="15">{
                varietyCount++
                score += 10
        }</span> else<span class="cov2" title="4"> {
                feedback = append(feedback, "Add numbers")
        }</span>

        <span class="cov4" title="19">if hasSymbol </span><span class="cov3" title="12">{
                varietyCount++
                score += 15
        }</span> else<span class="cov3" title="7"> {
                feedback = append(feedback, "Add symbols (!@#$%^&amp;*)")
        }</span>

        // Bonus for using all character types
        <span class="cov4" title="19">if varietyCount == 4 </span><span class="cov3" title="9">{
                score += 10
        }</span>

        // Pattern penalties
        <span class="cov4" title="19">if hasRepeatedChars(password) </span><span class="cov1" title="1">{
                score -= 10
                feedback = append(feedback, "Avoid repeated characters")
        }</span>

        <span class="cov4" title="19">if hasSequentialChars(password) </span><span class="cov3" title="11">{
                score -= 15
                feedback = append(feedback, "Avoid sequential characters (abc, 123)")
        }</span>

        <span class="cov4" title="19">if hasCommonPatterns(password) </span><span class="cov2" title="6">{
                score -= 20
                feedback = append(feedback, "Avoid common patterns")
        }</span>

        // Calculate entropy
        <span class="cov4" title="19">entropy := calculateEntropy(password)

        // Adjust score based on entropy
        if entropy &gt;= 60 </span><span class="cov3" title="9">{
                score += 20
        }</span> else<span class="cov3" title="10"> if entropy &gt;= 40 </span><span class="cov2" title="4">{
                score += 10
        }</span> else<span class="cov2" title="6"> if entropy &lt; 25 </span><span class="cov2" title="5">{
                score -= 15
                feedback = append(feedback, "Password is too predictable")
        }</span>

        // Ensure score is within bounds
        <span class="cov4" title="19">if score &lt; 0 </span><span class="cov2" title="5">{
                score = 0
        }</span>
        <span class="cov4" title="19">if score &gt; 100 </span><span class="cov1" title="1">{
                score = 100
        }</span>

        // Determine strength level
        <span class="cov4" title="19">level := getStrengthLevel(score)

        // Generate time to crack estimate
        timeToCrack := estimateTimeToCrack(entropy)

        // Add positive feedback for strong passwords
        if score &gt;= 80 &amp;&amp; len(feedback) == 0 </span><span class="cov1" title="2">{
                feedback = append(feedback, "Excellent password strength!")
        }</span>

        <span class="cov4" title="19">return PasswordStrength{
                Score:       score,
                Level:       level,
                Entropy:     entropy,
                Feedback:    feedback,
                TimeToCrack: timeToCrack,
        }</span>
}

func calculateEntropy(password string) float64 <span class="cov4" title="37">{
        // Determine character space
        charSpace := 0

        if regexp.MustCompile(`[a-z]`).MatchString(password) </span><span class="cov4" title="30">{
                charSpace += 26 // lowercase
        }</span>
        <span class="cov4" title="37">if regexp.MustCompile(`[A-Z]`).MatchString(password) </span><span class="cov4" title="23">{
                charSpace += 26 // uppercase
        }</span>
        <span class="cov4" title="37">if regexp.MustCompile(`[0-9]`).MatchString(password) </span><span class="cov4" title="26">{
                charSpace += 10 // digits
        }</span>
        <span class="cov4" title="37">if regexp.MustCompile(`[^a-zA-Z0-9]`).MatchString(password) </span><span class="cov4" title="19">{
                charSpace += 32 // common symbols
        }</span>

        <span class="cov4" title="37">if charSpace == 0 </span><span class="cov1" title="1">{
                return 0
        }</span>

        // Entropy = length * log2(character_space)
        <span class="cov4" title="36">entropy := float64(len(password)) * math.Log2(float64(charSpace))

        // Apply penalties for patterns
        if hasRepeatedChars(password) </span><span class="cov1" title="1">{
                entropy *= 0.8
        }</span>
        <span class="cov4" title="36">if hasSequentialChars(password) </span><span class="cov4" title="20">{
                entropy *= 0.7
        }</span>
        <span class="cov4" title="36">if hasCommonPatterns(password) </span><span class="cov3" title="10">{
                entropy *= 0.6
        }</span>

        <span class="cov4" title="36">return entropy</span>
}

func hasRepeatedChars(password string) bool <span class="cov5" title="59">{
        for i := 0; i &lt; len(password)-2; i++ </span><span class="cov8" title="909">{
                if password[i] == password[i+1] &amp;&amp; password[i+1] == password[i+2] </span><span class="cov2" title="4">{
                        return true
                }</span>
        }
        <span class="cov5" title="55">return false</span>
}

func hasSequentialChars(password string) bool <span class="cov5" title="60">{
        sequences := []string{
                "abcdefghijklmnopqrstuvwxyz",
                "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                "0123456789",
                "qwertyuiop", "asdfghjkl", "zxcvbnm",
                "QWERTYUIOP", "ASDFGHJKL", "ZXCVBNM",
        }

        lower := strings.ToLower(password)
        for _, seq := range sequences </span><span class="cov7" title="325">{
                for i := 0; i &lt;= len(seq)-3; i++ </span><span class="cov10" title="3909">{
                        if strings.Contains(lower, seq[i:i+3]) </span><span class="cov4" title="34">{
                                return true
                        }</span>
                }
        }

        // Check for reverse sequences
        <span class="cov4" title="26">for _, seq := range sequences </span><span class="cov6" title="226">{
                reversed := reverseString(seq)
                for i := 0; i &lt;= len(reversed)-3; i++ </span><span class="cov9" title="2424">{
                        if strings.Contains(lower, reversed[i:i+3]) </span><span class="cov1" title="1">{
                                return true
                        }</span>
                }
        }

        <span class="cov4" title="25">return false</span>
}

func hasCommonPatterns(password string) bool <span class="cov5" title="59">{
        commonPatterns := []string{
                "password", "123456", "qwerty", "admin", "login",
                "welcome", "monkey", "dragon", "master", "shadow",
                "letmein", "football", "iloveyou", "sunshine", "princess",
        }

        lower := strings.ToLower(password)
        for _, pattern := range commonPatterns </span><span class="cov8" title="691">{
                if strings.Contains(lower, pattern) </span><span class="cov3" title="14">{
                        return true
                }</span>
        }

        // Check for simple substitutions
        <span class="cov5" title="45">substitutions := map[string]string{
                "@": "a", "3": "e", "1": "i", "0": "o", "5": "s", "7": "t",
        }

        normalized := lower
        for symbol, letter := range substitutions </span><span class="cov7" title="270">{
                normalized = strings.ReplaceAll(normalized, symbol, letter)
        }</span>

        <span class="cov5" title="45">for _, pattern := range commonPatterns </span><span class="cov7" title="605">{
                if strings.Contains(normalized, pattern) </span><span class="cov2" title="5">{
                        return true
                }</span>
        }

        <span class="cov5" title="40">return false</span>
}

func getStrengthLevel(score int) StrengthLevel <span class="cov4" title="31">{
        switch </span>{
        case score &lt; 20:<span class="cov3" title="8">
                return VeryWeak</span>
        case score &lt; 40:<span class="cov1" title="2">
                return Weak</span>
        case score &lt; 60:<span class="cov2" title="4">
                return Fair</span>
        case score &lt; 80:<span class="cov3" title="9">
                return Good</span>
        case score &lt; 95:<span class="cov2" title="4">
                return Strong</span>
        default:<span class="cov2" title="4">
                return VeryStrong</span>
        }
}

func estimateTimeToCrack(entropy float64) string <span class="cov4" title="19">{
        // Assume 1 billion guesses per second (modern hardware)
        guessesPerSecond := 1e9

        // Number of possible combinations
        combinations := math.Pow(2, entropy)

        // Average time to crack (half the search space)
        secondsToCrack := combinations / (2 * guessesPerSecond)

        return formatDuration(secondsToCrack)
}</span>

func formatDuration(seconds float64) string <span class="cov4" title="28">{
        if seconds &lt; 1 </span><span class="cov2" title="6">{
                return "Instant"
        }</span> else<span class="cov4" title="22"> if seconds &lt; 60 </span><span class="cov1" title="2">{
                return fmt.Sprintf("%.0f seconds", seconds)
        }</span> else<span class="cov4" title="20"> if seconds &lt; 3600 </span><span class="cov1" title="1">{
                return fmt.Sprintf("%.0f minutes", seconds/60)
        }</span> else<span class="cov4" title="19"> if seconds &lt; 86400 </span><span class="cov1" title="1">{
                return fmt.Sprintf("%.0f hours", seconds/3600)
        }</span> else<span class="cov4" title="18"> if seconds &lt; 31536000 </span><span class="cov2" title="4">{
                return fmt.Sprintf("%.0f days", seconds/86400)
        }</span> else<span class="cov3" title="14"> if seconds &lt; 31536000000 </span><span class="cov1" title="2">{
                return fmt.Sprintf("%.0f years", seconds/31536000)
        }</span> else<span class="cov3" title="12"> if seconds &lt; 31536000000000 </span><span class="cov1" title="2">{
                return fmt.Sprintf("%.0f thousand years", seconds/31536000000)
        }</span> else<span class="cov3" title="10"> if seconds &lt; 31536000000000000 </span><span class="cov2" title="6">{
                return fmt.Sprintf("%.0f million years", seconds/31536000000000)
        }</span> else<span class="cov2" title="4"> {
                return fmt.Sprintf("%.0f billion years", seconds/31536000000000000)
        }</span>
}

func reverseString(s string) string <span class="cov6" title="226">{
        runes := []rune(s)
        for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov8" title="1388">{
                runes[i], runes[j] = runes[j], runes[i]
        }</span>
        <span class="cov6" title="226">return string(runes)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
